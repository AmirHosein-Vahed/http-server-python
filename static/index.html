<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>
    <style>
        body {
            background: linear-gradient(45deg, #0a192f, #112240, #233554);
            color: #64ffda;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: background 0.5s ease;
        }
        .cosmic-container {
            padding: 2rem;
            background: rgba(35, 53, 84, 0.7);
            border-radius: 20px;
            box-shadow: 0 0 30px #64ffda;
            margin: 2rem;
            animation: pulse 3s infinite;
            backdrop-filter: blur(10px);
        }
        h1 {
            font-size: 3rem;
            text-shadow: 0 0 10px #64ffda;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #64ffda, #00b4d8);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .floating-orbs {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .orb {
            position: absolute;
            background: radial-gradient(circle, #ff9933, #cc3300);
            border-radius: 50%;
            animation: float 8s infinite ease-in-out;
        }
        @keyframes glow {
            from { box-shadow: 0 0 30px #ff66ff; }
            to { box-shadow: 0 0 50px #ff99ff; }
        }
        @keyframes float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0); }
        }
        .game-container {
            background: rgba(51, 0, 102, 0.8);
            padding: 20px;
            margin: 20px;
            border-radius: 15px;
            max-width: 600px;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px auto;
            max-width: 300px;
        }
        .cell {
            background: rgba(255, 153, 51, 0.3);
            aspect-ratio: 1;
            border: 2px solid #ff9933;
            border-radius: 8px;
            cursor: pointer;
            font-size: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }
        .cell:hover {
            background: rgba(255, 153, 51, 0.5);
        }
        button {
            background: #ff9933;
            color: #1a0033;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background: #ffb366;
        }
        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px auto;
            max-width: 400px;
        }
        .memory-card {
            background: #ff9933;
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            transition: transform 0.3s;
            transform-style: preserve-3d;
        }
        .memory-card.flipped {
            transform: rotateY(180deg);
            background: #1a0033;
            color: #ff9933;
        }
        .memory-card:hover {
            opacity: 0.8;
        }
        .snake-canvas {
            background: rgba(51, 0, 102, 0.3);
            border: 2px solid #ff9933;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .space-canvas {
            background: rgba(51, 0, 102, 0.3);
            border: 2px solid #ff9933;
            border-radius: 8px;
            cursor: crosshair;
        }
        .breakout-canvas {
            background: rgba(51, 0, 102, 0.3);
            border: 2px solid #ff9933;
            border-radius: 8px;
        }
        .tetris-canvas {
            background: rgba(51, 0, 102, 0.3);
            border: 2px solid #ff9933;
            border-radius: 8px;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 30px #64ffda; }
            50% { box-shadow: 0 0 50px #00b4d8; }
            100% { box-shadow: 0 0 30px #64ffda; }
        }
    </style>
</head>
<body>
    <div class="floating-orbs" id="orbs"></div>
    <div class="cosmic-container">
        <h1>All these Games made by AI assisstant</h1>
        <p>Hello to vibe coding</p>
        <p>ðŸŽ® Let's Play Something Amazing ðŸŽ®</p>
    </div>
    <div class="game-container">
        <h2>Tic Tac Toe</h2>
        <div class="game-board" id="tictactoe">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>
        <button id="resetGame">Reset Game</button>
        <p id="gameStatus"></p>
    </div>
    <div class="game-container">
        <h2>Memory Game</h2>
        <div class="memory-board" id="memoryBoard"></div>
        <button id="resetMemory">New Game</button>
        <p id="memoryStatus"></p>
    </div>
    <div class="game-container">
        <h2>Snake Game</h2>
        <canvas id="snakeCanvas" class="snake-canvas" width="400" height="400"></canvas>
        <div class="controls">
            <button id="startSnake">Start Game</button>
            <button id="pauseSnake">Pause</button>
        </div>
        <p id="snakeScore">Score: 0</p>
    </div>
    <div class="game-container">
        <h2>Space Shooter</h2>
        <canvas id="spaceCanvas" class="space-canvas" width="400" height="400"></canvas>
        <div class="controls">
            <button id="startSpace">Start Game</button>
            <button id="resetSpace">Reset</button>
        </div>
        <p id="spaceScore">Score: 0</p>
        <p>Use mouse to move, click to shoot!</p>
    </div>
    <div class="game-container">
        <h2>Breakout</h2>
        <canvas id="breakoutCanvas" class="breakout-canvas" width="400" height="400"></canvas>
        <div class="controls">
            <button id="startBreakout">Start Game</button>
            <button id="resetBreakout">Reset</button>
        </div>
        <p id="breakoutScore">Score: 0</p>
        <p>Use left/right arrows to move paddle</p>
    </div>
    <div class="game-container">
        <h2>Tetris</h2>
        <canvas id="tetrisCanvas" class="tetris-canvas" width="300" height="600"></canvas>
        <div class="controls">
            <button id="startTetris">Start Game</button>
            <button id="pauseTetris">Pause</button>
        </div>
        <p id="tetrisScore">Score: 0</p>
        <p>Use arrow keys to move, Up to rotate</p>
    </div>
    <script>
        // Orbs creation code
        function createOrbs() {
            const orbsContainer = document.getElementById('orbs');
            for (let i = 0; i < 10; i++) {
                const orb = document.createElement('div');
                orb.className = 'orb';
                orb.style.left = Math.random() * 100 + 'vw';
                orb.style.top = Math.random() * 100 + 'vh';
                orb.style.width = Math.random() * 50 + 20 + 'px';
                orb.style.height = orb.style.width;
                orb.style.animationDelay = Math.random() * 5 + 's';
                orbsContainer.appendChild(orb);
            }
        }
        createOrbs();

        // Tic Tac Toe Game
        const TicTacToe = {
            currentPlayer: 'X',
            gameBoard: ['', '', '', '', '', '', '', '', ''],
            gameActive: true,
            winningCombos: [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ],
            handleCellClick: function(e) {
                const cell = e.target;
                const index = cell.getAttribute('data-index');
                if (this.gameBoard[index] === '' && this.gameActive) {
                    this.gameBoard[index] = this.currentPlayer;
                    cell.textContent = this.currentPlayer;
                    if (this.checkWin()) {
                        document.getElementById('gameStatus').textContent = `Player ${this.currentPlayer} wins!`;
                        this.gameActive = false;
                    } else if (!this.gameBoard.includes('')) {
                        document.getElementById('gameStatus').textContent = "It's a draw!";
                        this.gameActive = false;
                    } else {
                        this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                        document.getElementById('gameStatus').textContent = `Player ${this.currentPlayer}'s turn`;
                    }
                }
            },
            checkWin: function() {
                return this.winningCombos.some(combo => {
                    return combo.every(index => {
                        return this.gameBoard[index] === this.currentPlayer;
                    });
                });
            },
            resetGame: function() {
                this.gameBoard = ['', '', '', '', '', '', '', '', ''];
                this.gameActive = true;
                this.currentPlayer = 'X';
                document.querySelectorAll('.cell').forEach(cell => cell.textContent = '');
                document.getElementById('gameStatus').textContent = "Player X's turn";
            },
            init: function() {
                this.handleCellClick = this.handleCellClick.bind(this);
                this.resetGame = this.resetGame.bind(this);
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.addEventListener('click', this.handleCellClick);
                });
                document.getElementById('resetGame').addEventListener('click', this.resetGame);
                document.getElementById('gameStatus').textContent = "Player X's turn";
            }
        };

        // Memory Game
        const MemoryGame = {
            emojis: ['ðŸš€', 'ðŸŒŸ', 'ðŸŒ™', 'ðŸŒŽ', 'ðŸ’«', 'â­', 'ðŸ›¸', 'ðŸŒŒ'],
            cards: [],
            flippedCards: [],
            matchedPairs: 0,
            shuffleCards: function() {
                this.cards = [...this.emojis, ...this.emojis];
                this.cards.sort(() => Math.random() - 0.5);
                this.matchedPairs = 0;
                this.flippedCards = [];
                const board = document.getElementById('memoryBoard');
                board.innerHTML = '';
                this.cards.forEach((emoji, index) => {
                    const card = document.createElement('div');
                    card.className = 'memory-card';
                    card.dataset.value = emoji;
                    card.dataset.index = index;
                    card.addEventListener('click', (e) => this.flipCard(e.target));
                    board.appendChild(card);
                });
                document.getElementById('memoryStatus').textContent = 'Match the pairs!';
            },
            flipCard: function(card) {
                if (this.flippedCards.length === 2) return;
                if (this.flippedCards.includes(card)) return;
                card.textContent = card.dataset.value;
                card.classList.add('flipped');
                this.flippedCards.push(card);
                if (this.flippedCards.length === 2) {
                    setTimeout(() => this.checkMatch(), 500);
                }
            },
            checkMatch: function() {
                const [card1, card2] = this.flippedCards;
                if (card1.dataset.value === card2.dataset.value) {
                    this.matchedPairs++;
                    if (this.matchedPairs === this.emojis.length) {
                        document.getElementById('memoryStatus').textContent = 'Congratulations! You won!';
                    }
                } else {
                    card1.textContent = '';
                    card2.textContent = '';
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                }
                this.flippedCards = [];
            },
            init: function() {
                this.shuffleCards = this.shuffleCards.bind(this);
                document.getElementById('resetMemory').addEventListener('click', this.shuffleCards);
                this.shuffleCards();
            }
        };

        // Snake Game
        const SnakeGame = {
            canvas: null,
            ctx: null,
            snake: [{x: 10, y: 10}],
            food: {x: 15, y: 15},
            direction: 'right',
            score: 0,
            gameLoop: null,
            isPaused: false,
            GRID_SIZE: 20,
            GRID_COUNT: 20,
            init: function() {
                this.canvas = document.getElementById('snakeCanvas');
                this.ctx = this.canvas.getContext('2d');
                document.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    switch(e.key) {
                        case 'ArrowUp': if (this.direction !== 'down') this.direction = 'up'; break;
                        case 'ArrowDown': if (this.direction !== 'up') this.direction = 'down'; break;
                        case 'ArrowLeft': if (this.direction !== 'right') this.direction = 'left'; break;
                        case 'ArrowRight': if (this.direction !== 'left') this.direction = 'right'; break;
                    }
                });
                document.getElementById('startSnake').addEventListener('click', () => this.startGame());
                document.getElementById('pauseSnake').addEventListener('click', () => this.togglePause());
            },
            drawCell: function(x, y, color) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x * this.GRID_SIZE, y * this.GRID_SIZE, this.GRID_SIZE - 2, this.GRID_SIZE - 2);
            },
            updateGame: function() {
                const head = {...this.snake[0]};
                switch(this.direction) {
                    case 'up': head.y--; break;
                    case 'down': head.y++; break;
                    case 'left': head.x--; break;
                    case 'right': head.x++; break;
                }
                if (head.x < 0 || head.x >= this.GRID_COUNT || head.y < 0 || head.y >= this.GRID_COUNT ||
                    this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.endGame();
                    return;
                }
                this.snake.unshift(head);
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score += 10;
                    document.getElementById('snakeScore').textContent = `Score: ${this.score}`;
                    this.food = {
                        x: Math.floor(Math.random() * this.GRID_COUNT),
                        y: Math.floor(Math.random() * this.GRID_COUNT)
                    };
                } else {
                    this.snake.pop();
                }
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.snake.forEach(segment => this.drawCell(segment.x, segment.y, '#ff9933'));
                this.drawCell(this.food.x, this.food.y, '#ff66ff');
            },
            startGame: function() {
                if (this.gameLoop) return;
                this.snake = [{x: 10, y: 10}];
                this.direction = 'right';
                this.score = 0;
                document.getElementById('snakeScore').textContent = 'Score: 0';
                this.gameLoop = setInterval(() => this.updateGame(), 100);
                this.isPaused = false;
            },
            endGame: function() {
                clearInterval(this.gameLoop);
                this.gameLoop = null;
                this.ctx.fillStyle = 'rgba(255, 153, 51, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff66ff';
                this.ctx.font = '30px Arial';
                this.ctx.fillText('Game Over!', this.canvas.width/2 - 70, this.canvas.height/2);
            },
            togglePause: function() {
                if (!this.gameLoop) return;
                if (this.isPaused) {
                    this.gameLoop = setInterval(() => this.updateGame(), 100);
                    this.isPaused = false;
                } else {
                    clearInterval(this.gameLoop);
                    this.gameLoop = null;
                    this.isPaused = true;
                }
            }
        };

        // Space Shooter Game
        const SpaceShooter = {
            spaceCanvas: null,
            spaceCtx: null,
            spaceScore: 0,
            spaceGameLoop: null,
            player: { x: 200, y: 350, width: 40, height: 40 },
            bullets: [],
            enemies: [],
            isSpaceGameActive: false,
            zombieTypes: [
                { color: '#8B0000', points: 10, speed: 2, health: 1 },  // Regular zombie
                { color: '#006400', points: 20, speed: 3, health: 2 },  // Fast zombie
                { color: '#4B0082', points: 30, speed: 1, health: 3 }   // Tank zombie
            ],
            init: function() {
                this.spaceCanvas = document.getElementById('spaceCanvas');
                this.spaceCtx = this.spaceCanvas.getContext('2d');
                this.spaceCanvas.addEventListener('mousemove', (e) => {
                    if (!this.isSpaceGameActive) return;
                    const rect = this.spaceCanvas.getBoundingClientRect();
                    this.player.x = e.clientX - rect.left - this.player.width/2;
                    this.player.x = Math.max(0, Math.min(this.spaceCanvas.width - this.player.width, this.player.x));
                });
                this.spaceCanvas.addEventListener('click', (e) => {
                    if (!this.isSpaceGameActive) return;
                    this.bullets.push({
                        x: this.player.x + this.player.width/2 - 2,
                        y: this.player.y
                    });
                });
                document.getElementById('startSpace').addEventListener('click', () => this.startSpaceGame());
                document.getElementById('resetSpace').addEventListener('click', () => {
                    this.endSpaceGame();
                    this.startSpaceGame();
                });
            },
            drawPlayer: function() {
                this.spaceCtx.fillStyle = '#ff9933';
                this.spaceCtx.beginPath();
                this.spaceCtx.moveTo(this.player.x, this.player.y + this.player.height);
                this.spaceCtx.lineTo(this.player.x + this.player.width/2, this.player.y);
                this.spaceCtx.lineTo(this.player.x + this.player.width, this.player.y + this.player.height);
                this.spaceCtx.closePath();
                this.spaceCtx.fill();
            },
            createEnemy: function() {
                if (this.enemies.length < 5) {
                    const zombieType = this.zombieTypes[Math.floor(Math.random() * this.zombieTypes.length)];
                    this.enemies.push({
                        x: Math.random() * (this.spaceCanvas.width - 30),
                        y: 0,
                        width: 30,
                        height: 30,
                        speed: zombieType.speed,
                        health: zombieType.health,
                        points: zombieType.points,
                        color: zombieType.color
                    });
                }
            },
            drawZombie: function(enemy) {
                this.spaceCtx.fillStyle = enemy.color;
                // Body
                this.spaceCtx.fillRect(enemy.x, enemy.y + 10, enemy.width, enemy.height - 10);
                // Head
                this.spaceCtx.beginPath();
                this.spaceCtx.arc(enemy.x + enemy.width/2, enemy.y + 10, 10, 0, Math.PI * 2);
                this.spaceCtx.fill();
                // Health bar
                this.spaceCtx.fillStyle = '#ff0000';
                this.spaceCtx.fillRect(enemy.x, enemy.y - 5, (enemy.width * enemy.health) / enemy.points * 10, 3);
            },
            updateSpaceGame: function() {
                this.spaceCtx.clearRect(0, 0, this.spaceCanvas.width, this.spaceCanvas.height);
                // Update and draw bullets
                this.bullets = this.bullets.filter(bullet => {
                    bullet.y -= 5;
                    this.spaceCtx.fillStyle = '#ff66ff';
                    this.spaceCtx.fillRect(bullet.x, bullet.y, 4, 10);
                    return bullet.y > 0;
                });

                // Update and draw enemies
                this.enemies = this.enemies.filter(enemy => {
                    enemy.y += enemy.speed;
                    this.drawZombie(enemy);
                    
                    let isDestroyed = false;
                    this.bullets = this.bullets.filter(bullet => {
                        if (bullet.x < enemy.x + enemy.width &&
                            bullet.x > enemy.x &&
                            bullet.y < enemy.y + enemy.height &&
                            bullet.y > enemy.y) {
                            enemy.health--;
                            if (enemy.health <= 0) {
                                isDestroyed = true;
                                this.spaceScore += enemy.points;
                                document.getElementById('spaceScore').textContent = `Score: ${this.spaceScore}`;
                            }
                            return false;
                        }
                        return true;
                    });

                    if (enemy.y + enemy.height > this.player.y &&
                        enemy.x < this.player.x + this.player.width &&
                        enemy.x + enemy.width > this.player.x) {
                        this.endSpaceGame();
                        return false;
                    }

                    return !isDestroyed && enemy.y < this.spaceCanvas.height;
                });

                if (Math.random() < 0.03) this.createEnemy();
                this.drawPlayer();
            },
            startSpaceGame: function() {
                if (this.isSpaceGameActive) return;
                this.isSpaceGameActive = true;
                this.spaceScore = 0;
                this.enemies = [];
                this.bullets = [];
                document.getElementById('spaceScore').textContent = `Score: ${this.spaceScore}`;
                this.spaceGameLoop = setInterval(() => this.updateSpaceGame(), 1000/60);
            },
            endSpaceGame: function() {
                this.isSpaceGameActive = false;
                clearInterval(this.spaceGameLoop);
                this.spaceCtx.fillStyle = 'rgba(255, 153, 51, 0.5)';
                this.spaceCtx.fillRect(0, 0, this.spaceCanvas.width, this.spaceCanvas.height);
                this.spaceCtx.fillStyle = '#ff66ff';
                this.spaceCtx.font = '30px Arial';
                this.spaceCtx.fillText('Game Over!', this.spaceCanvas.width/2 - 70, this.spaceCanvas.height/2);
            }
        };

        // Breakout Game
        const Breakout = {
            canvas: null,
            ctx: null,
            score: 0,
            gameLoop: null,
            isActive: false,
            paddle: { x: 175, y: 380, width: 70, height: 10, speed: 8, velocity: 0 },
            keys: { left: false, right: false },
            ball: { x: 200, y: 200, dx: 3, dy: -3, radius: 5 },
            bricks: [],
            brickColors: ['#ff9933', '#ff66ff', '#cc3300', '#ff3366'],
            
            init: function() {
                this.canvas = document.getElementById('breakoutCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.createBricks();
                
                document.addEventListener('keydown', (e) => {
                    if (!this.isActive) return;
                    if (e.key === 'ArrowLeft') this.keys.left = true;
                    if (e.key === 'ArrowRight') this.keys.right = true;
                });

                document.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft') this.keys.left = false;
                    if (e.key === 'ArrowRight') this.keys.right = false;
                });

                document.getElementById('startBreakout').addEventListener('click', () => this.startGame());
                document.getElementById('resetBreakout').addEventListener('click', () => {
                    this.endGame();
                    this.startGame();
                });
            },

            createBricks: function() {
                this.bricks = [];
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 8; col++) {
                        this.bricks.push({
                            x: col * 50,
                            y: row * 25 + 20,
                            width: 48,
                            height: 23,
                            color: this.brickColors[row],
                            active: true
                        });
                    }
                }
            },

            update: function() {
                // Update paddle position based on key states
                if (this.keys.left) this.paddle.velocity = -this.paddle.speed;
                else if (this.keys.right) this.paddle.velocity = this.paddle.speed;
                else this.paddle.velocity *= 0.8; // Deceleration

                // Update paddle position with velocity
                this.paddle.x += this.paddle.velocity;
                this.paddle.x = Math.max(0, Math.min(this.canvas.width - this.paddle.width, this.paddle.x));

                // Move ball
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;

                // Wall collisions
                if (this.ball.x + this.ball.radius > this.canvas.width || this.ball.x - this.ball.radius < 0) {
                    this.ball.dx *= -1;
                }
                if (this.ball.y - this.ball.radius < 0) {
                    this.ball.dy *= -1;
                }
                if (this.ball.y + this.ball.radius > this.canvas.height) {
                    this.endGame();
                    return;
                }

                // Paddle collision
                if (this.ball.y + this.ball.radius > this.paddle.y &&
                    this.ball.x > this.paddle.x &&
                    this.ball.x < this.paddle.x + this.paddle.width) {
                    this.ball.dy = -Math.abs(this.ball.dy);
                }

                // Brick collisions
                this.bricks.forEach(brick => {
                    if (!brick.active) return;
                    if (this.ball.x > brick.x && 
                        this.ball.x < brick.x + brick.width &&
                        this.ball.y > brick.y &&
                        this.ball.y < brick.y + brick.height) {
                        brick.active = false;
                        this.ball.dy *= -1;
                        this.score += 10;
                        document.getElementById('breakoutScore').textContent = `Score: ${this.score}`;
                    }
                });

                this.draw();
            },

            draw: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw paddle
                this.ctx.fillStyle = '#ff9933';
                this.ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height);
                
                // Draw ball
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = '#ff66ff';
                this.ctx.fill();
                this.ctx.closePath();
                
                // Draw bricks
                this.bricks.forEach(brick => {
                    if (!brick.active) return;
                    this.ctx.fillStyle = brick.color;
                    this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                });
            },

            startGame: function() {
                if (this.isActive) return;
                this.isActive = true;
                this.score = 0;
                document.getElementById('breakoutScore').textContent = 'Score: 0';
                this.createBricks();
                this.ball = { x: 200, y: 200, dx: 3, dy: -3, radius: 5 };
                this.paddle = { x: 175, y: 380, width: 70, height: 10, speed: 8, velocity: 0 };
                this.keys = { left: false, right: false };
                this.gameLoop = setInterval(() => this.update(), 1000/60);
            },

            endGame: function() {
                this.isActive = false;
                clearInterval(this.gameLoop);
                this.ctx.fillStyle = 'rgba(255, 153, 51, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff66ff';
                this.ctx.font = '30px Arial';
                this.ctx.fillText('Game Over!', this.canvas.width/2 - 70, this.canvas.height/2);
            }
        };

        // Tetris Game
        const Tetris = {
            canvas: null,
            ctx: null,
            grid: [],
            currentPiece: null,
            score: 0,
            gameLoop: null,
            isActive: false,
            GRID_SIZE: 30,
            COLS: 10,
            ROWS: 20,
            pieces: [
                [[1, 1, 1, 1]], // I
                [[1, 1], [1, 1]], // O
                [[1, 1, 1], [0, 1, 0]], // T
                [[1, 1, 1], [1, 0, 0]], // L
                [[1, 1, 1], [0, 0, 1]], // J
                [[1, 1, 0], [0, 1, 1]], // S
                [[0, 1, 1], [1, 1, 0]]  // Z
            ],
            colors: ['#ff9933', '#ff66ff', '#cc3300', '#ff3366', '#9933ff', '#33ff99', '#ff3399'],

            init: function() {
                this.canvas = document.getElementById('tetrisCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.createGrid();

                document.addEventListener('keydown', (e) => {
                    if (!this.isActive) return;
                    switch(e.key) {
                        case 'ArrowLeft':
                            this.movePiece(-1, 0);
                            break;
                        case 'ArrowRight':
                            this.movePiece(1, 0);
                            break;
                        case 'ArrowDown':
                            this.movePiece(0, 1);
                            break;
                        case 'ArrowUp':
                            this.rotatePiece();
                            break;
                    }
                });

                document.getElementById('startTetris').addEventListener('click', () => this.startGame());
                document.getElementById('pauseTetris').addEventListener('click', () => this.togglePause());
            },

            createGrid: function() {
                this.grid = Array(this.ROWS).fill().map(() => Array(this.COLS).fill(0));
            },

            createPiece: function() {
                const index = Math.floor(Math.random() * this.pieces.length);
                const piece = this.pieces[index];
                return {
                    shape: JSON.parse(JSON.stringify(piece)), // Deep copy the shape
                    originalShape: piece, // Keep reference to original shape
                    color: this.colors[index],
                    x: Math.floor(this.COLS / 2) - Math.floor(piece[0].length / 2),
                    y: 0
                };
            },

            drawPiece: function() {
                if (!this.currentPiece) return;
                this.currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            this.ctx.fillStyle = this.currentPiece.color;
                            this.ctx.fillRect(
                                (this.currentPiece.x + x) * this.GRID_SIZE,
                                (this.currentPiece.y + y) * this.GRID_SIZE,
                                this.GRID_SIZE - 1,
                                this.GRID_SIZE - 1
                            );
                        }
                    });
                });
            },

            drawGrid: function() {
                this.grid.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            this.ctx.fillStyle = this.colors[value - 1];
                            this.ctx.fillRect(
                                x * this.GRID_SIZE,
                                y * this.GRID_SIZE,
                                this.GRID_SIZE - 1,
                                this.GRID_SIZE - 1
                            );
                        }
                    });
                });
            },

            collision: function(x = 0, y = 0) {
                return this.currentPiece.shape.some((row, dy) => {
                    return row.some((value, dx) => {
                        if (!value) return false;
                        const newX = this.currentPiece.x + dx + x;
                        const newY = this.currentPiece.y + dy + y;
                        return newX < 0 || newX >= this.COLS || newY >= this.ROWS ||
                               (newY >= 0 && this.grid[newY][newX]);
                    });
                });
            },

            movePiece: function(x, y) {
                this.currentPiece.x += x;
                this.currentPiece.y += y;
                if (this.collision()) {
                    this.currentPiece.x -= x;
                    this.currentPiece.y -= y;
                    if (y > 0) this.mergePiece();
                    return false;
                }
                return true;
            },

            rotatePiece: function() {
                const original = this.currentPiece.shape;
                // Create new rotated matrix
                const rotated = Array(original[0].length).fill()
                    .map((_, i) => Array(original.length).fill()
                        .map((_, j) => original[original.length - 1 - j][i]));
                
                const previousShape = this.currentPiece.shape;
                this.currentPiece.shape = rotated;

                // Check boundaries and collisions
                if (this.collision()) {
                    // Try to adjust position if near walls
                    const kicks = [-1, 1, -2, 2]; // Possible position adjustments
                    let validKick = false;
                    
                    for (let kick of kicks) {
                        this.currentPiece.x += kick;
                        if (!this.collision()) {
                            validKick = true;
                            break;
                        }
                        this.currentPiece.x -= kick;
                    }
                    
                    if (!validKick) {
                        this.currentPiece.shape = previousShape;
                    }
                }
            },

            mergePiece: function() {
                this.currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const gridY = this.currentPiece.y + y;
                            if (gridY < 0) {
                                this.endGame();
                                return;
                            }
                            // Store the piece color index directly
                            this.grid[gridY][this.currentPiece.x + x] = 
                                this.pieces.findIndex(p => p === this.currentPiece.originalShape) + 1;
                        }
                    });
                });
                this.checkLines();
                this.currentPiece = this.createPiece();
            },

            checkLines: function() {
                let linesCleared = 0;
                this.grid.forEach((row, y) => {
                    if (row.every(value => value !== 0)) {
                        this.grid.splice(y, 1);
                        this.grid.unshift(Array(this.COLS).fill(0));
                        linesCleared++;
                    }
                });
                if (linesCleared) {
                    this.score += linesCleared * 100;
                    document.getElementById('tetrisScore').textContent = `Score: ${this.score}`;
                }
            },

            update: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGrid();
                this.drawPiece();
                if (!this.movePiece(0, 1)) {
                    this.currentPiece = this.createPiece();
                    if (this.collision()) {
                        this.endGame();
                    }
                }
            },

            startGame: function() {
                if (this.isActive) return;
                this.isActive = true;
                this.score = 0;
                this.createGrid();
                this.currentPiece = this.createPiece();
                document.getElementById('tetrisScore').textContent = 'Score: 0';
                this.gameLoop = setInterval(() => this.update(), 500);
            },

            togglePause: function() {
                if (!this.isActive) return;
                if (this.gameLoop) {
                    clearInterval(this.gameLoop);
                    this.gameLoop = null;
                } else {
                    this.gameLoop = setInterval(() => this.update(), 500);
                }
            },

            endGame: function() {
                this.isActive = false;
                clearInterval(this.gameLoop);
                this.ctx.fillStyle = 'rgba(255, 153, 51, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ff66ff';
                this.ctx.font = '30px Arial';
                this.ctx.fillText('Game Over!', this.canvas.width/2 - 70, this.canvas.height/2);
            }
        };

        // Initialize all games
        window.addEventListener('load', () => {
            TicTacToe.init();
            MemoryGame.init();
            SnakeGame.init();
            SpaceShooter.init();
            Breakout.init();
            Tetris.init();
        });
    </script>
</body>
</html>