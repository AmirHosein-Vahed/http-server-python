<!DOCTYPE html>
<html>
<head>
    <title>RoboCup SSL Simulation</title>
    <style>
        #field {
            background: #008000;
            border: 2px solid white;
            display: block;
            margin: 20px auto;
            transform-origin: center center;
        }
        .controls {
            text-align: center;
            margin: 10px;
        }
        button {
            padding: 10px 20px;
            margin: 0 5px;
            cursor: pointer;
        }
        .controls button {
            margin: 0 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <canvas id="field" width="900" height="600"></canvas>
    <div class="controls">
        <button id="start">Start</button>
        <button id="stop">Stop</button>
        <button id="resetBall">Reset Ball</button>
    </div>

    <script>
        class Robot {
            constructor(x, y, team, role = 'fielder') {
                this.x = x;
                this.y = y;
                this.team = team;
                this.role = role;
                this.direction = 0;
                this.speed = 0;
                this.targetX = x;
                this.targetY = y;
                this.baseX = x;
                this.baseY = y;
                this.hasBall = false;
                this.passCooldown = 0;
                this.targetDirection = 0;
                this.rotationSpeed = 0.1;
                this.isAiming = false;
                this.zoneX = x;  // Base position for zone coverage
                this.zoneY = y;
                this.zoneRadius = 150; // How far from base position robot can move
                this.maxSpeed = 4; // Reduced from 6
                this.acceleration = 0.1; // Reduced from 0.2
                this.currentSpeed = 0;
                this.rotationAccel = 0.08; // Reduced from 0.15
                this.isCharging = false;
                this.maxShootPower = 25;
            }

            isInAllowedZone(x, y) {
                // Check if position is within allowed zone and field boundaries
                const inZone = Math.hypot(x - this.zoneX, y - this.zoneY) <= this.zoneRadius;
                const inField = x >= 60 && x <= 840 && y >= 60 && y <= 540;
                return inZone && inField;
            }

            update() {
                // Handle rotation with smooth acceleration
                const angleDiff = this.targetDirection - this.direction;
                if (Math.abs(angleDiff) > 0.1) {
                    const rotationDir = Math.sign(((angleDiff + Math.PI) % (Math.PI * 2)) - Math.PI);
                    this.direction += rotationDir * this.rotationAccel;
                }

                if (!this.isAiming) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const targetDirection = Math.atan2(dy, dx);
                    const distToTarget = Math.hypot(dx, dy);

                    // Smooth acceleration and deceleration
                    if (distToTarget > 5) {
                        this.currentSpeed = Math.min(this.currentSpeed + this.acceleration, this.maxSpeed);
                    } else {
                        this.currentSpeed = Math.max(this.currentSpeed - this.acceleration, 0);
                    }

                    // Move with current speed
                    if (this.currentSpeed > 0) {
                        const moveX = Math.cos(targetDirection) * this.currentSpeed;
                        const moveY = Math.sin(targetDirection) * this.currentSpeed;
                        this.x += moveX * 0.8; // Add dampening factor
                        this.y += moveY * 0.8;
                    }

                    // Collision avoidance with smooth response
                    this.game.robots.forEach(other => {
                        if (other !== this) {
                            const dist = Math.hypot(other.x - this.x, other.y - this.y);
                            if (dist < 40) {
                                const angle = Math.atan2(other.y - this.y, other.x - this.x);
                                const repulsionForce = (40 - dist) * 0.1;
                                this.x -= Math.cos(angle) * repulsionForce;
                                this.y -= Math.sin(angle) * repulsionForce;
                            }
                        }
                    });
                }
                
                // Keep robots within field bounds smoothly
                this.x = Math.max(20, Math.min(880, this.x));
                this.y = Math.max(20, Math.min(580, this.y));
            }

            findBestPassTarget() {
                let bestTarget = null;
                let bestScore = -Infinity;
                
                this.game.robots.forEach(teammate => {
                    if (teammate !== this && teammate.team === this.team && !teammate.isGoalkeeper) {
                        const distToTeammate = Math.hypot(teammate.x - this.x, teammate.y - this.y);
                        if (distToTeammate > 50 && distToTeammate < 300) {
                            let score = 1000 - distToTeammate;
                            
                            // Check if pass path is blocked by opponents
                            this.game.robots.forEach(opponent => {
                                if (opponent.team !== this.team) {
                                    const distToPassLine = this.pointToLineDistance(
                                        opponent.x, opponent.y,
                                        this.x, this.y,
                                        teammate.x, teammate.y
                                    );
                                    if (distToPassLine < 30) {
                                        score -= 500;
                                    }
                                }
                            });
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestTarget = teammate;
                            }
                        }
                    }
                });
                return bestTarget;
            }

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                return Math.hypot(px - xx, py - yy);
            }

            updateStrategy() {
                const ball = this.game.ball;
                const isYellow = this.team === 'yellow';
                const goalX = isYellow ? 850 : 50;  // Target opposite goal
                const teamDirection = isYellow ? 1 : -1;

                // Set zone positions based on role and team
                switch(this.role) {
                    case 'striker':
                        this.zoneX = isYellow ? 600 : 300;
                        this.zoneRadius = 200;
                        break;
                    case 'midfielder':
                        this.zoneX = 450 + teamDirection * 100;
                        this.zoneRadius = 150;
                        break;
                    case 'defender':
                        this.zoneX = isYellow ? 200 : 700;
                        this.zoneRadius = 120;
                        break;
                    case 'sweeper':
                        this.zoneX = isYellow ? 250 : 650;
                        this.zoneRadius = 100;
                        break;
                    case 'winger':
                        this.zoneX = 450 + teamDirection * 150;
                        this.zoneRadius = 180;
                        break;
                }

                // Find if this robot is closest to ball
                let isClosest = true;
                let closestDist = Math.hypot(this.x - ball.x, this.y - ball.y);
                this.game.robots.forEach(other => {
                    if (other !== this && !other.isGoalkeeper && other.team === this.team) {
                        const otherDist = Math.hypot(other.x - ball.x, this.y - ball.y);
                        if (otherDist < closestDist) isClosest = false;
                    }
                });

                // Check if path to goal is blocked
                let isPathBlocked = false;
                this.game.robots.forEach(opponent => {
                    if (opponent.team !== this.team) {
                        const distToGoalLine = this.pointToLineDistance(
                            opponent.x, opponent.y,
                            ball.x, ball.y,
                            goalX, 300
                        );
                        if (distToGoalLine < 50) {
                            isPathBlocked = true;
                        }
                    }
                });

                if (isClosest && isPathBlocked && Date.now() > this.passCooldown) {
                    const passTarget = this.findBestPassTarget();
                    if (passTarget) {
                        // Execute pass
                        const angle = Math.atan2(passTarget.y - ball.y, passTarget.x - ball.x);
                        this.game.ball.vx = Math.cos(angle) * 15;
                        this.game.ball.vy = Math.sin(angle) * 15;
                        this.passCooldown = Date.now() + 2000; // 2 second cooldown
                    }
                }

                // Calculate path to goal
                const ballToGoalX = goalX - ball.x;
                const ballToGoalY = 300 - ball.y;
                const ballToGoalAngle = Math.atan2(ballToGoalY, ballToGoalX);

                // Modified shooting logic
                if (this.hasBall) {
                    const distToGoal = Math.hypot(goalX - this.x, 300 - this.y);
                    if (distToGoal < 300) {
                        // Shoot at goal with randomness
                        const goalY = 300 + (Math.random() - 0.5) * 60;
                        this.shoot(goalX, goalY);
                    } else if (isPathBlocked) {
                        // Look for passing opportunities
                        const passTarget = this.findBestPassTarget();
                        if (passTarget) {
                            this.shoot(passTarget.x, passTarget.y);
                        }
                    }
                }

                // Calculate target position
                let targetX = this.targetX;
                let targetY = this.targetY;

                if (this.hasBall) {
                    // If has ball, move towards goal while staying in allowed zone
                    const goalAngle = Math.atan2(300 - this.y, goalX - this.x);
                    targetX = this.x + Math.cos(goalAngle) * 5;
                    targetY = this.y + Math.sin(goalAngle) * 5;
                } else if (isClosest && this.isInAllowedZone(ball.x, ball.y)) {
                    // Chase ball if closest and ball is in zone
                    targetX = ball.x;
                    targetY = ball.y;
                } else {
                    // Return to zone center
                    targetX = this.zoneX;
                    targetY = this.zoneY;
                }

                // Ensure target is within allowed zone
                if (!this.isInAllowedZone(targetX, targetY)) {
                    const angle = Math.atan2(targetY - this.zoneY, targetX - this.zoneX);
                    targetX = this.zoneX + Math.cos(angle) * this.zoneRadius;
                    targetY = this.zoneY + Math.sin(angle) * this.zoneRadius;
                }

                this.targetX = targetX;
                this.targetY = targetY;
            }

            shoot(targetX, targetY) {
                if (!this.hasBall) return false;
                
                const targetAngle = Math.atan2(targetY - this.y, targetX - this.x);
                const angleDiff = Math.abs(targetAngle - this.direction);
                
                // If not facing the right direction, aim first
                if (angleDiff > 0.1) {
                    this.targetDirection = targetAngle;
                    this.isAiming = true;
                    return false;
                }
                
                // If aimed correctly, shoot immediately
                this.isAiming = false;
                const shotPower = 20; // Fixed shot power
                const angle = this.direction;
                this.game.ball.vx = Math.cos(angle) * shotPower;
                this.game.ball.vy = Math.sin(angle) * shotPower;
                
                this.passCooldown = Date.now() + 1000;
                return true;
            }
        }

        class Goalkeeper extends Robot {
            constructor(x, y, team) {
                super(x, y, team);
                this.isGoalkeeper = true;
                this.goalY = y;
            }

            update() {
                // Follow ball on Y axis only
                if (this.team === 'yellow') {
                    this.x = 70;  // Fixed X position for yellow goalkeeper
                    this.targetY = Math.min(Math.max(this.game.ball.y, 200), 400);
                } else {
                    this.x = 830;  // Fixed X position for blue goalkeeper
                    this.targetY = Math.min(Math.max(this.game.ball.y, 200), 400);
                }
                this.y += (this.targetY - this.y) * 0.1;
            }
        }

        class Ball {
            constructor() {
                this.x = 450;
                this.y = 300;
                this.vx = 0;
                this.vy = 0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;

                // Bounce off walls
                if (this.x < 0 || this.x > 900) this.vx *= -0.8;
                if (this.y < 0 || this.y > 600) this.vy *= -0.8;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('field');
                this.ctx = this.canvas.getContext('2d');
                this.robots = [];
                this.ball = new Ball();
                this.running = false;
                this.score = { yellow: 0, blue: 0 };

                // Initialize robots with specific roles
                this.robots = [
                    new Goalkeeper(70, 300, 'yellow'),
                    new Robot(200, 300, 'yellow', 'striker'),
                    new Robot(150, 200, 'yellow', 'defender'),
                    new Robot(250, 400, 'yellow', 'sweeper'),
                    new Robot(300, 250, 'yellow', 'winger'),
                    new Robot(300, 350, 'yellow', 'midfielder'),
                    
                    new Goalkeeper(830, 300, 'blue'),
                    new Robot(700, 300, 'blue', 'striker'),
                    new Robot(750, 200, 'blue', 'defender'),
                    new Robot(650, 400, 'blue', 'sweeper'),
                    new Robot(600, 250, 'blue', 'winger'),
                    new Robot(600, 350, 'blue', 'midfielder')
                ];

                // Give robots reference to game
                this.robots.forEach(robot => robot.game = this);
                
                this.lastFoul = 0;
                this.foulTeam = null;

                this.zoom = 1;
                this.setupControls();
                this.setupEvents();
                this.setupZoom();
            }

            setupControls() {
                document.getElementById('start').onclick = () => this.start();
                document.getElementById('stop').onclick = () => this.stop();
                document.getElementById('resetBall').onclick = () => this.resetBall();
            }

            setupEvents() {
                this.canvas.onclick = (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Move closest robot to clicked position
                    let closest = this.robots[0];
                    let minDist = Number.MAX_VALUE;
                    
                    this.robots.forEach(robot => {
                        const dist = Math.hypot(robot.x - x, robot.y - y);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = robot;
                        }
                    });

                    closest.targetX = x;
                    closest.targetY = y;
                };
            }

            setupZoom() {
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoom = Math.max(0.5, Math.min(2, this.zoom * delta));
                    
                    // Apply zoom transformation
                    this.canvas.style.transform = `scale(${this.zoom})`;
                });
            }

            start() {
                this.running = true;
                this.gameLoop();
            }

            stop() {
                this.running = false;
            }

            gameLoop() {
                if (!this.running) return;
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                this.ball.update();

                // Remove the random position changes
                // Update all players continuously
                const ballPos = { x: this.ball.x, y: this.ball.y };
                const yellowPlayers = this.robots.filter(r => r.team === 'yellow' && !r.isGoalkeeper);
                const bluePlayers = this.robots.filter(r => r.team === 'blue' && !r.isGoalkeeper);

                // Update each team's strategy
                this.updateTeamStrategy(yellowPlayers, ballPos);
                this.updateTeamStrategy(bluePlayers, ballPos);

                // Update all robots
                this.robots.forEach(robot => {
                    if (!robot.isGoalkeeper) {
                        robot.updateStrategy();
                    }
                    robot.update();
                });

                // Ball collision checks with improved handling
                this.robots.forEach(robot => {
                    const dist = Math.hypot(robot.x - this.ball.x, robot.y - this.ball.y);
                    if (dist < 25) { // Increased collision distance
                        // Calculate deflection angle
                        const angle = Math.atan2(this.ball.y - robot.y, this.ball.x - robot.x);
                        const ballSpeed = Math.hypot(this.ball.vx, this.ball.vy);
                        const robotSpeed = robot.currentSpeed;
                        
                        // Combine velocities for realistic collision
                        const resultSpeed = (ballSpeed + robotSpeed) * 0.5;
                        this.ball.vx = Math.cos(angle) * resultSpeed;
                        this.ball.vy = Math.sin(angle) * resultSpeed;
                        
                        // Push ball away from robot
                        this.ball.x = robot.x + Math.cos(angle) * 25;
                        this.ball.y = robot.y + Math.sin(angle) * 25;
                    }
                });

                // Update ball possession
                this.robots.forEach(robot => {
                    const dist = Math.hypot(robot.x - this.ball.x, robot.y - this.ball.y);
                    robot.hasBall = dist < 20;
                });

                // Referee rules
                this.checkFouls();
                this.checkOutOfBounds();

                // Check for goals
                if (this.ball.x < 50 && this.ball.y > 250 && this.ball.y < 350) {
                    this.score.blue++;
                    this.resetBall();
                }
                if (this.ball.x > 850 && this.ball.y > 250 && this.ball.y < 350) {
                    this.score.yellow++;
                    this.resetBall();
                }
            }

            updateTeamStrategy(players, ballPos) {
                // Sort players by distance to ball
                players.sort((a, b) => {
                    const distA = Math.hypot(a.x - ballPos.x, a.y - ballPos.y);
                    const distB = Math.hypot(b.x - ballPos.x, b.y - ballPos.y);
                    return distA - distB;
                });

                // Closest player chases ball
                const closestPlayer = players[0];
                if (closestPlayer) {
                    closestPlayer.targetX = ballPos.x;
                    closestPlayer.targetY = ballPos.y;
                }

                // Others maintain strategic positions
                players.slice(1).forEach((player, index) => {
                    switch (player.role) {
                        case 'striker':
                            player.targetX = ballPos.x + (player.team === 'yellow' ? 50 : -50);
                            player.targetY = ballPos.y;
                            break;
                        case 'midfielder':
                            player.targetX = 450 + (player.team === 'yellow' ? -100 : 100);
                            player.targetY = 300 + (index % 2 ? 100 : -100);
                            break;
                        case 'defender':
                            player.targetX = player.team === 'yellow' ? 200 : 700;
                            player.targetY = ballPos.y;
                            break;
                        case 'sweeper':
                            player.targetX = player.team === 'yellow' ? 250 : 650;
                            player.targetY = 300;
                            break;
                        case 'winger':
                            player.targetX = 450 + (player.team === 'yellow' ? -150 : 150);
                            player.targetY = index % 2 ? 450 : 150;
                            break;
                    }
                });
            }

            resetBall() {
                this.ball.x = 450;
                this.ball.y = 300;
                this.ball.vx = 0;
                this.ball.vy = 0;
            }

            checkFouls() {
                if (Date.now() - this.lastFoul < 3000) return;

                // Check for out of bounds fouls
                this.robots.forEach(robot => {
                    if (robot.x < 50 || robot.x > 850 || robot.y < 50 || robot.y > 550) {
                        this.lastFoul = Date.now();
                        this.foulTeam = robot.team;
                        this.handleFoul(robot.x, robot.y);
                    }
                });

                // Check for robot collisions
                this.robots.forEach(robot1 => {
                    this.robots.forEach(robot2 => {
                        if (robot1 !== robot2) {
                            const dist = Math.hypot(robot1.x - robot2.x, robot1.y - robot2.y);
                            if (dist < 30) {
                                this.lastFoul = Date.now();
                                this.foulTeam = robot1.team;
                                this.handleFoul(robot1.x, robot1.y);
                            }
                        }
                    });
                });
            }

            handleFoul(x, y) {
                // Move ball to foul location
                this.ball.x = x;
                this.ball.y = y;
                this.ball.vx = 0;
                this.ball.vy = 0;
                
                // Move opposing team away
                const opposingTeam = this.foulTeam === 'yellow' ? 'blue' : 'yellow';
                this.robots.forEach(robot => {
                    if (robot.team === opposingTeam) {
                        const dist = Math.hypot(robot.x - x, robot.y - y);
                        if (dist < 50) {
                            const angle = Math.atan2(robot.y - y, robot.x - x);
                            robot.targetX = x + Math.cos(angle) * 60;
                            robot.targetY = y + Math.sin(angle) * 60;
                        }
                    }
                });
            }

            checkOutOfBounds() {
                if (this.ball.x < 50 || this.ball.x > 850 || 
                    this.ball.y < 50 || this.ball.y > 550) {
                    this.resetBall();
                }
            }

            draw() {
                // Apply zoom transformation to drawing context
                this.ctx.save();
                this.ctx.scale(this.zoom, this.zoom);
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw field markings
                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(50, 50, 800, 500);
                this.ctx.beginPath();
                this.ctx.arc(450, 300, 50, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Draw goals
                this.ctx.fillStyle = 'yellow';
                this.ctx.fillRect(0, 250, 50, 100);
                this.ctx.fillStyle = 'blue';
                this.ctx.fillRect(850, 250, 50, 100);

                // Draw additional field markings
                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = 2;
                
                // Center line
                this.ctx.beginPath();
                this.ctx.moveTo(450, 50);
                this.ctx.lineTo(450, 550);
                this.ctx.stroke();

                // Penalty areas
                this.ctx.strokeRect(50, 200, 100, 200);  // Yellow penalty area
                this.ctx.strokeRect(750, 200, 100, 200); // Blue penalty area

                // Corner arcs
                this.drawCornerArc(50, 50);    // Top left
                this.drawCornerArc(850, 50);   // Top right
                this.drawCornerArc(50, 550);   // Bottom left
                this.drawCornerArc(850, 550);  // Bottom right

                // Foul indicator
                if (Date.now() - this.lastFoul < 3000) {
                    this.ctx.fillStyle = 'red';
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText('FOUL!', 420, 30);
                }

                // Draw ball
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, 5, 0, Math.PI * 2);
                this.ctx.fill();

                // Draw robots
                this.robots.forEach(robot => {
                    this.ctx.fillStyle = robot.team;
                    this.ctx.beginPath();
                    this.ctx.arc(robot.x, robot.y, 15, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw role indicator
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(robot.role[0], robot.x - 4, robot.y + 4);
                    
                    // Draw direction indicator
                    this.ctx.strokeStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.moveTo(robot.x, robot.y);
                    this.ctx.lineTo(
                        robot.x + Math.cos(robot.direction) * 20,
                        robot.y + Math.sin(robot.direction) * 20
                    );
                    this.ctx.stroke();
                });

                // Add score display
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Arial';
                this.ctx.fillText(`Yellow: ${this.score.yellow} - Blue: ${this.score.blue}`, 380, 30);

                this.ctx.restore();
            }

            drawCornerArc(x, y) {
                this.ctx.beginPath();
                const startAngle = x < 450 ? 0 : Math.PI;
                const endAngle = x < 450 ? Math.PI/2 : 3*Math.PI/2;
                this.ctx.arc(x, y, 20, startAngle, endAngle);
                this.ctx.stroke();
            }
        }

        const game = new Game();
    </script>
</body>
</html>
